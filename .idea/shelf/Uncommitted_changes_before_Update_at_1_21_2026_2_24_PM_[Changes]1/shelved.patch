Index: components/workflows/WorkflowCanvas.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// components/workflows/WorkflowCanvas.tsx\r\n\"use client\";\r\n\r\nimport React, { useState } from \"react\";\r\nimport { DndContext, DragEndEvent, DragOverlay, useSensor, useSensors, PointerSensor, useDraggable } from \"@dnd-kit/core\";\r\nimport { AppNode } from \"@/lib/utils/types\";\r\nimport { TriggerNode } from \"./NodeTypes/TriggerNode\";\r\nimport { ActionNode } from \"./NodeTypes/ActionNode\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\ninterface CanvasProps {\r\n  initialNodes?: AppNode[];\r\n  onSave: (nodes: AppNode[]) => void;\r\n}\r\n\r\n/**\r\n * Draggable Wrapper Component\r\n * ---------------------------\r\n * Acts as the \"Physics Body\" for our visual nodes.\r\n * It separates the drag mechanics (event listeners, transform math)\r\n * from the presentation logic (TriggerNode/ActionNode).\r\n */\r\nfunction DraggableNode({ id, left, top, children }: { id: string, left: number, top: number, children: React.ReactNode }) {\r\n  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({\r\n    id: id,\r\n  });\r\n\r\n  /*\r\n   * PERFORMANCE OPTIMIZATION: CSS TRANSFORMS\r\n   * ----------------------------------------\r\n   * During the drag operation (which fires ~60 times per second), we use\r\n   * CSS `transform` rather than updating `top/left` state.\r\n   * * Why?\r\n   * 1. 'transform' runs on the GPU (Compositor thread).\r\n   * 2. 'top/left' triggers Layout recalculations on the CPU (Main thread).\r\n   * This ensures buttery smooth 60fps dragging even with complex nodes.\r\n   */\r\n  const style = {\r\n    position: \"absolute\" as \"absolute\",\r\n    left: left,\r\n    top: top,\r\n    // Apply the temporary delta during the drag\r\n    transform: transform ? `translate3d(${transform.x}px, ${transform.y}px, 0)` : undefined,\r\n    zIndex: isDragging ? 1000 : 1, // Z-Index promotion prevents clipping behind other nodes\r\n    touchAction: \"none\", // Critical: Disables browser scrolling on touch devices while dragging\r\n  };\r\n\r\n  return (\r\n    <div ref={setNodeRef} style={style} {...listeners} {...attributes}>\r\n      {children}\r\n    </div>\r\n  );\r\n}\r\n\r\n/**\r\n * Main Workflow Canvas (Infinite Whiteboard)\r\n * ------------------------------------------\r\n * Orchestrates the node state and drag context.\r\n * * ARCHITECTURAL NOTE:\r\n * We are using @dnd-kit here, which provides excellent \"free-form\" dragging primitives.\r\n * However, unlike React Flow, it does not handle *Edges* (lines between nodes) out of the box.\r\n * Future Scope: An SVG layer must be added behind these nodes to render connections.\r\n */\r\nexport function WorkflowCanvas({ initialNodes = [], onSave }: CanvasProps) {\r\n  const [nodes, setNodes] = useState<AppNode[]>(initialNodes);\r\n  const [activeId, setActiveId] = useState<string | null>(null);\r\n\r\n  /*\r\n   * SENSOR CONFIGURATION\r\n   * --------------------\r\n   * We require a movement of 5 pixels (activationConstraint) before a drag registers.\r\n   * This differentiates a \"Click\" (to select/edit a node) from a \"Drag\" (to move it).\r\n   * Without this, users would accidentally move nodes every time they tried to click settings.\r\n   */\r\n  const sensors = useSensors(\r\n    useSensor(PointerSensor, {\r\n      activationConstraint: {\r\n        distance: 5,\r\n      },\r\n    })\r\n  );\r\n\r\n  const addNode = (type: \"TRIGGER\" | \"ACTION\") => {\r\n    // Basic heuristics to prevent nodes from stacking directly on top of each other\r\n    const offset = nodes.length * 30;\r\n\r\n    const newNode: AppNode = {\r\n      id: uuidv4(),\r\n      workflowId: \"temp\",\r\n      type,\r\n      // Default to common types for MVP\r\n      connectorType: type === \"TRIGGER\" ? \"gmail-new-email\" : \"slack-send-message\",\r\n      config: {},\r\n      positionX: 100 + offset,\r\n      positionY: 100 + offset,\r\n      parentId: null,\r\n      childId: null,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n    setNodes((prev) => [...prev, newNode]);\r\n  };\r\n\r\n  /**\r\n   * Finalizes the drag operation.\r\n   * Merges the temporary `transform` delta into the permanent `positionX/Y` state.\r\n   */\r\n  function handleDragEnd(event: DragEndEvent) {\r\n    const { active, delta } = event;\r\n\r\n    setNodes((prev) =>\r\n      prev.map((node) => {\r\n        if (node.id === active.id) {\r\n          return {\r\n            ...node,\r\n            // Calculate new absolute coordinates\r\n            positionX: node.positionX + delta.x,\r\n            positionY: node.positionY + delta.y,\r\n          };\r\n        }\r\n        return node;\r\n      })\r\n    );\r\n    setActiveId(null);\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex h-screen flex-col bg-slate-50\">\r\n      {/* TOOLBAR */}\r\n      <div className=\"border-b bg-white p-4 flex justify-between items-center shadow-sm z-10\">\r\n        <div className=\"flex gap-2\">\r\n          <Button onClick={() => addNode(\"TRIGGER\")} variant=\"outline\" className=\"border-blue-200 bg-blue-50 text-blue-700 hover:bg-blue-100\">\r\n            + Add Trigger\r\n          </Button>\r\n          <Button onClick={() => addNode(\"ACTION\")} variant=\"outline\" className=\"border-gray-200 bg-gray-50 text-gray-700 hover:bg-gray-100\">\r\n            + Add Action\r\n          </Button>\r\n        </div>\r\n        <div className=\"flex gap-2 items-center\">\r\n           <span className=\"text-sm text-gray-500 mr-4\">\r\n             {nodes.length} nodes\r\n           </span>\r\n           <Button onClick={() => onSave(nodes)}>Save Workflow</Button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* CANVAS AREA */}\r\n      <div className=\"flex-1 relative overflow-hidden\">\r\n\r\n        {/* Empty State: Guide the user when the canvas is blank */}\r\n        {nodes.length === 0 && (\r\n          <div className=\"absolute inset-0 flex items-center justify-center text-gray-400 pointer-events-none\">\r\n            <div className=\"text-center\">\r\n              <p className=\"text-2xl mb-2 font-semibold\">Empty Canvas</p>\r\n              <p>Click \"Add Trigger\" to start building</p>\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        <DndContext\r\n          sensors={sensors}\r\n          onDragStart={(e) => setActiveId(e.active.id as string)}\r\n          onDragEnd={handleDragEnd}\r\n        >\r\n          {nodes.map((node) => (\r\n            <DraggableNode\r\n              key={node.id}\r\n              id={node.id}\r\n              left={node.positionX}\r\n              top={node.positionY}\r\n            >\r\n              {/* Dynamic Component Loading based on Node Type */}\r\n              {node.type === \"TRIGGER\" ? (\r\n                <TriggerNode data={node} />\r\n              ) : (\r\n                <ActionNode data={node} />\r\n              )}\r\n            </DraggableNode>\r\n          ))}\r\n\r\n          {/* Overlay is technically optional for simple drags, but useful if we wanted\r\n            to show a different \"Drag Preview\" (e.g. a semi-transparent ghost)\r\n            while the user is moving the item.\r\n          */}\r\n          <DragOverlay>\r\n             {activeId ? (\r\n               <div className=\"opacity-80\"></div>\r\n             ) : null}\r\n          </DragOverlay>\r\n        </DndContext>\r\n      </div>\r\n    </div>\r\n  );\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/components/workflows/WorkflowCanvas.tsx b/components/workflows/WorkflowCanvas.tsx
--- a/components/workflows/WorkflowCanvas.tsx	
+++ b/components/workflows/WorkflowCanvas.tsx	
@@ -26,24 +26,13 @@
     id: id,
   });
 
-  /*
-   * PERFORMANCE OPTIMIZATION: CSS TRANSFORMS
-   * ----------------------------------------
-   * During the drag operation (which fires ~60 times per second), we use
-   * CSS `transform` rather than updating `top/left` state.
-   * * Why?
-   * 1. 'transform' runs on the GPU (Compositor thread).
-   * 2. 'top/left' triggers Layout recalculations on the CPU (Main thread).
-   * This ensures buttery smooth 60fps dragging even with complex nodes.
-   */
   const style = {
     position: "absolute" as "absolute",
     left: left,
     top: top,
-    // Apply the temporary delta during the drag
     transform: transform ? `translate3d(${transform.x}px, ${transform.y}px, 0)` : undefined,
     zIndex: isDragging ? 1000 : 1, // Z-Index promotion prevents clipping behind other nodes
-    touchAction: "none", // Critical: Disables browser scrolling on touch devices while dragging
+    touchAction: "none",
   };
 
   return (
